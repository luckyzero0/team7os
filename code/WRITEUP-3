#WRITEUP#

Writeup for Project 3, Spring2011
03/30/2011


Team 24:	Nick Bopp		nbopp@usc.edu

			Mihir Sheth		mihirshe@usc.edu

			James Cramer	jcramer@usc.edu


---USAGE---
To build Nachos:
	gmake (inside the vm directory for Parts 1/2, but inside the network directory for part 2)
	
To build coff2noff:
	gmake coff2noff (inside the bin directory)
	
To build all the tests:
	make all (inside the test directory)

To run parts 1/2 tests:
	nachos -x ../test/EXECUTABLE_NAME (inside the vm directory)
	
To run part 3 tests:
	


---DOCUMENTATION---

I. REQUIREMENTS

	Project 3 has two main components, the implementation of a basic virtual memory system and the implementation
	of some basic Remote Procedure Calls.

II. ASSUMPTIONS

	1. A reasonable number of threads / processes are being run on the virtual memory system (if you do too many, it seems
		like the program is hung, but it actually just context switching so much that very little real work gets done).  These programs
		do successfully complete, but can page fault in the range of tens of millions of times.
		
	2. For Part 3, only one address space is running per process (no Exec'ing in the user program).

III. DESIGN

	Parts 1/2:
		Our design follows the pattern set by Professor Crowley in the lecture.
		Main steps:
			1. Check the TLB for virtual page
			2. If not in the TLB, page fault.
			3. Check the IPT for the correct virtual page
				a. If it's there copy to the TLB and return.
				b. If it's not, look for an available physical page.
				c. If no physical pages are available, select a RANDOM or FIFO one to evict.
					i. Propagate dirty bit up from the TLB to the IPT.
					ii. If IPT page is dirty, write it to the swap file.
					iii. Update the page table for the evicted page.
				d. Read the needed virtual page into physical memory from the executable, swap file, or by bzero'ing.
			4. Copy the entry from the IPT to the TLB.
			5. Restart the user instruction.
			
	Part 3:
		
	
!!!! NECESSARY MACHINE.H CHANGES FOR YOU, THE GRADER, TO MAKE !!!!!
	1. Replace #define NumPhysPages xxxx with,
	#ifdef USE_TLB
	#define NumPhysPages 32
	#else
	#define NumPhysPages 16500
	#endif
	
	2. Replace #define MaxMailSize
	/* JAY COMPLETE */
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

IV. IMPLEMENTATION

	Parts 1/2:
	+ Files Modified
		- exception.cc
		- addrspace.h/cc
		- system.cc
		
		- syscall.h
		- synch.h/cc
		- server.cc
	
	+ Files Added
		- test/* (All the tests in the test directory)
		- vm/ipt.h
		
	+ Data Structures Added
		Lock* iptLock;
		IPTEntry ipt[];
		
		
	+ Data Structures Modified
		Added Lock* pageTableLock to each AddrSpace.
		Changed class of pageTable to IPTEntry*.
			
	+ Functions Added
		- New syscalls
			. HandlePageFault()
			+ Supporting Subroutines
				- HandleIPTMiss()
				- UpdateTLB()
				- EvictPageFromTLB()
				- HandleFullMemory()
				
	Part 3:
	+ Files Modified
		- syscall.h
		- synch.h/cc
		- server.cc
	
	+ Files Added
		
	+ Data Structures Added
		
	+ Data Structures Modified
		NONE
			
	+ Functions Added
		
V. TESTING

	+ How to Test
	
		See USAGE above.
		
		The .c's listed below are the tests.  For example, to build, just do "gmake forkTest".
		
		PARTS 1 AND 2: ----------------------------------------------------------------------
	
				/*forkTest.c*/
		/* 
		 * Tests for forking. Checks against bad construction data,
		 * and confirms that two threads can run concurrently modifying
		 * global data.
		 * If successfull, x = 10 at the end of the test.
		 */
		 
				 /* halt.c
		 *	Simple program to test whether running a user program works.
		 *	
		 *	Just do a "syscall" that shuts down the OS.
		 *
		 * 	NOTE: for some reason, user programs with global data structures 
		 *	sometimes haven't worked in the Nachos environment.  So be careful
		 *	out there!  One option is to allocate data structures as 
		 * 	automatics within a procedure, but if you do this, you have to
		 *	be careful to allocate a big enough stack to hold the automatics!
		 */
		 
				 /* matmult.c 
		 *    Test program to do matrix multiplication on large arrays.
		 *
		 *    Intended to stress virtual memory system.
		 *
		 *    Ideally, we could read the matrices off of the file system,
		 *	and store the result back to the file system!
		 */
		 
				/*randTest.c*/
		*	Produces a few random numbers.
		*	Should always produce the exact same numbers for a given -rs value
		*/
		
				/* sort.c 
		*    Test program to sort a large number of integers.
		*
		*    Intention is to stress virtual memory system.
		*
		*    Ideally, we could read the unsorted array off of the file system,
		*	and store the result back to the file system!
		*/
		
				/*testConditions.c*/
		/*
		 * Tests CVs. Attempt to pass bad construction data,
		 * as well as access CVs with bad parameters.
		 * If successfully, bad CVs are not created, and
		 * t2 will run before t1.
		 * Finally, tests broadcast. If successful, all threads will
		 * exit.
		 */
		 
				 /*execTest.c*/
		/*
		 *	Tests the Exec function call with some bad input
		 *	as well as a normative case.
		 */
		 
				 /* exec_testLocks.c */
		/*	This will run the test "testLocks"
		*	in 9 processes simultaneously, then shutdown.
		*/
		 
				/* forkArg.c */
		/*	This test tries out the GetForkArg syscall to make sure that
		*	threads receive the appropriate argument. The behavior for
		*	GetForkArg on threads not forked with an arg is not guaranteed,
		*	but right now the implementation always returns -2.
		*/
		
				/* testLocks.c */
		/*	Quick test program to check if lock related SYSCALLS are working.
		* 	Performs a few tests to check bad construction data, as well as
		* 	Passing bad lock IDs to demonstrate attempting to acquire non-owned
		* 	locks.
		* 	The final test demonstrates a small mutex scenario, in which the final
		* 	result of raceCondition should should be 0, 5, or 10, depending on which
		* 	thread runs first, but never any value in between.
		*/

		
		PART 3: Passport Simulation ---------------------------------------------------------------------------------------------
		
				/* officeMain.c */
		/*	This runs the office with the default values of 3 of each clerk,
		*	20 customers, and 3 senators.  Everything should escape the office,
		*	and the sum of cashier money should be $2300.
		*/
		
				/* officeMainDEBUG.c */
		/*	This runs the office with the default values of 3 of each clerk,
		*	20 customers, and 3 senators, with TESTING flag turned on for 
		*   enhanced output. Everything should escape the office,
		*	and the sum of cashier money should be $2300.
		*/
		
				/* exec_office.c */
		/* 
		 * Execs 4 office programs to run simultaneously to 
		 * test multiprogramming.
		 */
		 
			 /*senatorTest.c*/
		/* This test is to show that customers
		 * behave property in the presence
		 * of the allpowerful senators. 2 customers are
		 * forked and 1 senator. Everyone should exit 
		 * at the end.
		 */
		 
			 /*clerkBreakTest.c*/
		/* 
		 * Test showing that clerks go on break when there
		 * are no customers in their lines. The test forks
		 * 2 of each clerk and 0 customers, so that they 
		 * will go on break once the simulation starts.
		 */
		 
		 
			 /*customerCashiertest.c*/
		/*
		 *	Test to demonstrate customers entering and leaving the passport office,
		 *  but only interactions with the cashier clerk, namely that they only leave once
		 *  they received their passport, and that the cashclerk only interacts with them
		 *  one at a time. Forks 3 customers to only do a routine to run the doCashClerk() 
		 *	in customer, and sets valid = true for all of them, so they can pay the cashier
		 * 	and leave.
		*/	
		
			/*customerLinetest.c*/
		/* Checks to make sure customers always
		 * choose the shortest line. Manually sets the
		 * line length of the appLine to 3. No clerks
		 * are forked in this test, so the program exits
		 * once all customers have gotten in line.
		 */
		 
			 /*managerClerkTest.c*/
		/* This test shows that the manager
		 * wakes up clerks if they have people in their lines.
		 * This is simulated by forking customers before clerks.
		 * The forked ManagerClerkTest function sets the line lengths
		 * to test values, but no customers are forked. The program
		 * will exit after all clerks wake up.
		 */
		 
		 
		 	/*ManagerTest.c*/
		/*
		 * Test to ensure that the
		 * Manager does not check multiple clerks
		 * at the same time. 2 of each clerk are forked,
		 * and their cash values set to 500 each, except
		 * the cashier, who has 0. This is to trigger
		 * the managers cashChecking routine, which executes
		 * when cashier's cash == numCustomers*100. No customers
		 * are forked, so the value must be 0.
		 */


VI. DISCUSSION

The only really weird thing we have experienced with this project is the EXTREME slowness when using more than 3 processes or threads.
They constantly interrupt each other and invalidate the TLB, so only in lucky changes (where context switches are temporarily spaced apart),
does a thread get the CPU long enough to execute a few lines of user instruction.  The program looks like it is hanging, but it really isn't, 
it is just constantly context switching and causing the necessary page faults.  Programs will complete, just in a VERY long amount of time (like an
hour if exec 4 matmults).  Note that this only happens with -rs values, because if you don't -rs, we don't get the crazy often context switches.

It turns out that disabling interrupts at the top of HandlePageFault actually speeds up our code dramatically in this case, because threads are
able to complete their work without invalidating the TLB and doing it over and over again.  In our submitted code, we DO NOT disable interrupts
for the whole page fault, despite this speed up when running more than 3-4 processes / threads with -rs enabled.


VII. MISCELLANEOUS

Please feel free to contact us if you have any questions. We'd be happy to meet to meet up and discuss any issues/what's going on in our code.
Please contact us by emailing Nick Bopp at nbopp@usc.edu.


	
